<head>
  <title>Meteor Blaze Components</title>
</head>

<body>
<h1>Meteor Blaze Components</h1>

<p>Blaze Components for <a href="https://meteor.com/">Meteor</a> are a system for easily developing
  complex UI elements that need to be reused around your Meteor app.</p>

{{! TODO: Put this link somewhere better. Maybe at the end? Or maybe we should add a GitHub ribbon? }}
<p><a href="https://github.com/peerlibrary/meteor-blaze-components">Documentation and source code on GitHub</a>.</p>

<h2>The Problem</h2>

<p>Let's say we have an input box that auto-selects the text on click for easier changing. Its value is read from the
database and is written to it when the user changes it.</p>

<p>In plain Meteor this looks something like this:</p>

<div class="demo">
  <div class="live">
    {{> input id='demo1'}}
    {{> autoSelectDemo id='demo1'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; input id='demo1'}}

&lt;template name=&quot;input&quot;&gt;
  &lt;input value="{{|value}}"/&gt;
&lt;/template&gt;</code></pre>

    <pre class="coffee"><code class="language-coffeescript">Template.input.helpers
  value: -&gt;
    # Read value from the collection.
    Values.findOne(@id)?.value

Template.input.events
  # Save value to the collection when it changes.
  'change input': (event, template) -&gt;
    Values.upsert @id, $set: value: event.target.value

  # Auto-select text when user clicks in the input.
  'click input': (event, template) -&gt;
    $(event.target).select()</code></pre>
  </div>
</div>

<p>What if we now want the same functionality on another template?</p>

<p>Our options are:</p>
<ul>
  <li>
    <p>Duplicate the code to the other template.</p>
  </li>
  <li>
    <p>Refactor the template to <code class="language-handlebars">{{|> include}}</code> another template, or create
      a <code class="language-handlebars">{{|#block}}</code> helper that provides the functionality.</p>
  </li>
  <li>
    <p>Refactor the code instead. We save the reusable helpers and event handlers into variables and apply them on
      multiple templates.</p>
  </li>
  <li>
    <p>Create a helper class that does the same as above in an organized way and also provides inheritance, so you can
    create modified versions or extend the functionality.</p>
  </li>
</ul>
<p>What if the last option didn't require separate helper class, but it was simply how templates worked?</p>
<p>That's what Blaze Components are!</p>

<h2>The Solution</h2>

<p>Let's make our auto-select input into a Blaze Component. You can think of a component, just like you would of a
  template, except the functionality (helpers and events) are defined through a class.</p>

<div class="demo">
  <div class="live">
    {{> AutoSelectInputComponent id='demo2'}}
    {{> autoSelectDemo id='demo2'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; AutoSelectInputComponent id='demo2'}}</code></pre>

    <pre class="coffee"><code class="language-coffeescript">class AutoSelectInputComponent extends BlazeComponent
  @register 'AutoSelectInputComponent'

  template: -&gt;
    'input'

  value: -&gt;
    Values.findOne(@data().id)?.value

  events: -&gt;
    super.concat
      'change input': @onChange
      'click input': @onClick

  onChange: (event) -&gt;
    Values.upsert @data().id, $set: value: event.target.value

  onClick: (event) -&gt;
    $(event.target).select()</code></pre>
  </div>
</div>
<p>Let's look at the code part by part.</p>

<pre class="coffee"><code class="language-coffeescript">class AutoSelectInputComponent extends BlazeComponent
  @register 'AutoSelectInputComponent'</code></pre>

<p>We have created an <code class="language-coffeescript">AutoSelectInputComponent</code> and registered it
  so we can include it just as any other template in our templates.</p>

<aside>
  <p>The convention would be to use <code class="language-coffeescript">AutoSelectInputComponent</code> for the
    template name, to match the component's class name (and its registration name).</p>
  <p>We are breaking the convention in this specific case to reuse an existing template.</p>
</aside>

<pre class="coffee"><code class="language-coffeescript">  template: -&gt;
    'input'</code></pre>

<p>The <code class="language-coffeescript">input</code> template we provided earlier will serve
as the markup to be re-used by the component.</p>
<p>However, all the helpers and events will be provided through the component class.</p>

<p>
  Helpers are simply instance methods.
</p>

<aside>
  <p>
    Notice that to get the data context, we need to call the <code class="language-coffeescript">@data()</code> function,
    similar to how we call <code class="language-coffeescript">@data</code> in template hooks and
    <code class="language-coffeescript">template.data</code> in event handlers.
  </p>
  <p>
    In normal template helpers <code class="language-coffeescript">@</code> refers to the data context, but is not
    reactive. Neither is <code class="language-coffeescript">@data</code> or
    <code class="language-coffeescript">template.data</code>, so we had to call
    <code class="language-coffeescript">Template.currentData()</code> when we wanted to register a dependency.
  </p>
  <p>
    In Blaze Components, things are consistent: <code class="language-coffeescript">@</code> always refers to the
    component instance and <code class="language-coffeescript">@data()</code> is always a reactive reference to the data
    context.
  </p>
</aside>

<pre class="coffee"><code class="language-coffeescript">  value: -&gt;
    Values.findOne(@data().id)?.value</code></pre>

<p>
  Events are returned with the <code class="language-coffeescript">events</code> method like before, although instead of
  defining the handlers inline, we rather have them as instance methods, so we can override them from child classes
  later.
</p>

<pre class="coffee"><code class="language-coffeescript">  events: -&gt;
    super.concat
      'change input': @onChange
      'click input': @onClick

  onChange: (event) -&gt;
    Values.upsert @data().id, $set: value: event.target.value

  onClick: (event) -&gt;
    $(event.target).select()</code></pre>

<h2>The Beauty</h2>

<p>Components allow us to create new components that share code simply through inheritance.</p>
<p>Let's say we want to provide the same functionality to a textarea template.</p>

<div class="demo">
  <div class="live">
    {{> AutoSelectTextareaComponent id='demo3'}}
    {{> autoSelectDemo id='demo3'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; AutoSelectCanvasComponent id='demo3'}}

&lt;template name="autoSelectTextarea"&gt;
  &lt;textarea&gt;{{|value}}&lt;/textarea&gt;
&lt;/template&gt;</code></pre>

    <pre class="coffee"><code class="language-coffeescript">class AutoSelectTextareaComponent extends AutoSelectInputComponent
  @register 'AutoSelectTextareaComponent'

  template: -&gt;
    'autoSelectTextarea'

  events: -&gt;
    super.concat
      'change textarea': @onChange
      'click textarea': @onClick</code></pre>
  </div>
</div>

<p>Now we only need to inherit from the parent template, override which template to use and hook the event handlers for
textarea as well.</p>
<p>This could be made even simpler if our original component already hooked the events in a generic way, like</p>

<pre class="coffee"><code class="language-coffeescript">events: -&gt;
  super.concat
    'change *': @onChange
    'click *': @onClick</code></pre>

<hr/>

<p>An input form element will only update once we press enter or click outside it. Since Meteor's great strength is its
  reactivity, it would be nice if inputs updated in real-time as we type.</p>
<p>We'll call this extension real-time input. All we need to do is add in the code that calls the change event on
  each keypress.</p>

<div class="demo">
  <div class="live">
    {{> RealTimeInputComponent id='demo4'}}
    {{> autoSelectDemo id='demo4'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; RealTimeInputComponent id='demo4'}}</code></pre>

    <pre class="coffee"><code class="language-coffeescript">class RealTimeInputComponent extends AutoSelectInputComponent
  @register 'RealTimeInputComponent'

  events: -&gt;
    super.concat
      'keyup input': @onKeyup

  onKeyup: (event) -&gt;
    $(event.target).change()</code></pre>
  </div>
</div>
<p>You might have experienced so far, that the input randomly updated while you were typing. This is because the value
in the input boxes come from a single database. If any other user has changed the text in the input, the value is
  reactively propagated to everywhere else in the world where this page is opened!</p>
  <p>Try opening another browser side by side and observe as the values change in both windows. In the example below,
we are simulating a change every 3 seconds for convenience.</p>
<p>In such collaborative environments, we need to make sure that the value in the input box doesn't change while you're
editing it. To enable this, we'll store the current value when the input box gets focus and keep returning it to
  the rendering engine while we're editing, even if the reactive change would demand otherwise. This will trick the
  rendering engine to think that nothing has changed and will not cause re-rendering.</p>

<div class="demo">
  <div class="live">
    {{> PersistentInputComponent id='demo5'}}
    {{> autoSelectDemo id='demo5'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; PersistentInputComponent id='demo5'}}</code></pre>

    <pre class="coffee"><code class="language-coffeescript">class PersistentInputComponent extends AutoSelectInputComponent
  @register 'PersistentInputComponent'

  onCreated: -&gt;
    super
    # This will store the value at the start of editing.
    @storedValue = new ReactiveVar()

  value: -&gt;
    # Return stored value during editing or normal otherwise.
    @storedValue.get() or super

  events: -&gt;
    super.concat
      'focus input': @onFocus
      'blur input': @onBlur

  onFocus: (event) -&gt;
    # Store the current value when starting to edit.
    @storedValue.set @value()

  onBlur: (event) -&gt;
    # We are no longer editing, so return to normal.
    @storedValue.set null</code></pre>
  </div>
</div>

<h2>The Cooperation</h2>

<p>What if we want to now have an input-box that is both real-time and persistent during editing?</p>

<figure>
  <img src="images/Diamond-01.svg">
</figure>

<p>This cannot be expressed in a single-inheritance language such as JavaScript and CoffeeScript that use the
  prototype chain for inheritance.</p>

<p>Since a lot of class-based languages also do not support multiple inheritance (and those that do run into
  <a href="http://en.wikipedia.org/wiki/Multiple_inheritance">the diamond problem</a>) a principle of
  <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance</a> has been
    developed. You might have already encountered one implementation of this called mixins.</p>

<p>Mixins provide small chunks of self-contained functionality. In our case we can have a mixin that just handles
auto-selection, another one for real-time input, third for frozen state. Our
  <code class="language-coffeescript">SmartInputComponent</code> would then include all three mixins.</p>

<figure>
  <img src="images/Diamond-02.svg">
</figure>

<p>This provides for good separation of concerns. The <code class="language-coffeescript">SmartInputComponent</code>
  will implement the specific logic of reading and writing the value to the database, while delegating to mixins to
  handle their own minimal implementation of the single things they're supposed to do.</p>

<div class="demo">
  <div class="live">
    {{> SmartInputComponent id='demo6'}}
    {{> autoSelectDemo id='demo6'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; SmartInputComponent id='demo6'}}</code></pre>

    <pre class="coffee"><code class="language-coffeescript">class SmartInputComponent extends BlazeComponent
  @register 'SmartInputComponent'

  template: -&gt;
    'input'

  mixins: -&gt;
    [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin]

  value: -&gt;
    @callMixinWith(@, 'value') or Values.findOne(@data().id)?.value

  events: -&gt;
    super.concat
      'change input': @onChange

  onChange: (event) -&gt;
    Values.upsert @data().id, $set: value: event.target.value</code></pre>
  </div>
</div>

<p>The code for the <code class="language-coffeescript">SmartInputComponent</code> above is very similar to what we
  did so far, with two differences.</p>
<p>We use the <code class="language-coffeescript">mixins</code> method to return the list of classes that we want to
  include in our component.</p>

<pre class="coffee"><code class="language-coffeescript">mixins: -&gt;
  [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin]</code></pre>

<p>We also need to modify our value helper to allow mixins to override it.</p>

<aside>
  <p>
    <code class="language-coffeescript">callMixinWith</code> will find one of the mixins that has the specified
  function defined and call just that one.</p>
  <p>If you want to execute the function on all mixins that have it implemented,
    use <code class="language-coffeescript">callMixins</code> instead. The results will be collected into an array.</p>
</aside>

<pre class="coffee"><code class="language-coffeescript">value: -&gt;
  @callMixinWith(@, 'value') or Values.findOne(@data().id)?.value</code></pre>

<p>In inheritance we need to call <code class="language-coffeescript">super</code> to get the result of a function
we are overriding &mdash; otherwise the child completely shadows that function. With mixins we have to perform the same
thing to get the result from a mixin's implementation. That's what the
  <code class="language-coffeescript">callMixinWith</code> function does.</p>

<p>Let's quickly glance over all three mixins. The code is very self explanatory.</p>

<p><code class="language-coffeescript">AutoSelectInputMixin</code> selects the input on click.</p>

<pre class="coffee"><code class="language-coffeescript">class AutoSelectInputMixin extends BlazeComponent
  events: ->
    super.concat
      'click input': @onClick

  onClick: (event) ->
    $(event.target).select()</code></pre>

<p><code class="language-coffeescript">RealTimeInputMixin</code> fires change events on every keystroke.</p>

<pre class="coffee"><code class="language-coffeescript">class RealTimeInputMixin extends BlazeComponent
  events: ->
    super.concat
      'keyup input': @onKeyUp

  onKeyUp: (event) ->
    $(event.target).change()</code></pre>

<p>And the <code class="language-coffeescript">PersistentInputMixin</code> stores the value while editing.</p>

<pre class="coffee"><code class="language-coffeescript">class PersistentInputMixin extends BlazeComponent
  onCreated: ->
    @storedValue = new ReactiveVar()

  value: ->
    @storedValue.get()

  events: ->
    super.concat
      'focus input': @onFocus
      'blur input': @onBlur

  onFocus: (event) ->
    @storedValue.set @mixinParent().value()

  onBlur: (event) ->
    @storedValue.set null</code></pre>

<p>Becuase the mixin needs to control the output of <code class="language-coffeescript">value</code>, our
  <code class="language-coffeescript">SmartInputComponent</code> needs the mentioned
  <code class="language-coffeescript">callMixinWith</code> call from its own
  <code class="language-coffeescript">value</code> function.
</p>

<hr/>

<p>TODO: Mixins demo 2 text.</p>

<div class="demo">
  <div class="live">
    {{> EvenSmarterInputComponent id='demo7'}}
    {{> autoSelectDemo id='demo7'}}
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars">{{|&gt; EvenSmarterInputComponent id='demo7'}}</code></pre>

    <pre class="coffee"><code class="language-coffeescript"># TODO</code></pre>
  </div>
</div>

{{!
TEMPLATE FOR THE DEMO

Copy/paste when adding a new section.

<div class="demo">
  <div class="live">
  </div>

  <div class="code">
    <pre class="html"><code class="language-handlebars"></code></pre>

    <pre class="coffee"><code class="language-coffeescript"></code></pre>
  </div>
</div>
}}

{{! TODO: Things we should probably mention/show/demo are all sections from the README: passing arguments to components (better than through data context) and animations. }}

{{! TODO: Maybe we should repeat a link to complete documentation/reference and source code/GitHub at the end again. }}

</body>

<template name="autoSelectDemo">
  {{#if value}}
    <p>The stored value is {{value}}.</p>
  {{else}}
    <p>Please type in something.</p>
  {{/if}}
</template>

<template name="input">
  <input value="{{value}}"/>
</template>

<template name="autoSelectTextarea">
  <textarea>{{value}}</textarea>
</template>
